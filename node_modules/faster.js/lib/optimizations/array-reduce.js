'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.createReduceVisitor = createReduceVisitor;

var _utils = require('../utils');

exports.default = createReduceVisitor(false);

/**
 * Returns a function that returns a visitor that rewrites
 * array.reduce() or array.reduceRight() calls as for loops.
 *
 * Only supports assignments and single declarations:
 *     results = arr.reduce(f); // assignment
 *     const results = arr.reduce(f); // single declaration
 */

function createReduceVisitor(reduceRight) {
	var methodName = reduceRight ? 'reduceRight' : 'reduce';
	return function (t) {
		return {
			ExpressionStatement(path, state) {
				var expression = path.node.expression;
				if (!(0, _utils.isIdAssignment)(t, expression) || !(0, _utils.isMethodCall)(t, expression.right, methodName)) {
					return;
				}

				var assignee = expression.left;

				var acc = writeReduceForLoop(t, path, path.get('expression.right'), reduceRight);
				path.replaceWith(t.assignmentExpression('=', assignee, acc));
			},

			VariableDeclaration(path, state) {
				if (path.node.declarations.length !== 1) return;

				if (!(0, _utils.isMethodCall)(t, path.node.declarations[0].init, methodName)) {
					return;
				}

				var reducePath = path.get('declarations.0.init');
				var acc = writeReduceForLoop(t, path, reducePath, reduceRight);
				reducePath.replaceWith(acc);
			}
		};
	};
}

// Returns the identifier the result is stored in.
function writeReduceForLoop(t, path, reducePath, reduceRight) {
	var reduceCall = reducePath.node;
	var array = (0, _utils.defineIdIfNeeded)(t, reducePath.get('callee.object'), path);
	var func = (0, _utils.extractDynamicFuncIfNeeded)(t, reducePath, path);
	var acc = path.scope.generateUidIdentifier('acc');
	var i = path.scope.generateUidIdentifier('i');

	// Initialize the accumulator.
	// let acc = arguments[1] || (reduceRight ? arr[arr.length - 1] : arr[0]);
	var initVal = reduceCall.arguments[1] || (0, _utils.arrayMember)(t, array, 0, reduceRight);
	path.insertBefore(t.VariableDeclaration('let', [t.VariableDeclarator(acc, initVal)]));

	// Write the for loop.
	var newReduceCall = t.callExpression(func, [acc, t.memberExpression(array, i, true), i, array]);
	var forBody = t.blockStatement([t.expressionStatement(t.assignmentExpression('=', acc, newReduceCall))]);
	var initI = void 0;
	if (!reduceCall.arguments[1]) {
		initI = reduceRight ? (0, _utils.arrayIndex)(t, array, 1, true) : t.numericLiteral(1);
	}
	path.insertBefore((0, _utils.basicArrayForLoop)(t, i, array, forBody, reduceRight, initI));

	return acc;
}