'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _utils = require('../utils');

/**
 * Returns a visitor that rewrites array.filter() calls as a for loop.
 *
 * Only supports assignments and single declarations:
 *     results = arr.filter(f); // assignment
 *     const results = arr.filter(f); // single declaration
 *
 * Only supports 1 argument:
 *     arr.filter(f); // call with 1 argument will get compiled
 *     arr.filter(f, this); // call with 2 arguments won't get compiled
 */
exports.default = function (t) {
	return {
		ExpressionStatement(path, state) {
			var expression = path.node.expression;
			if (!(0, _utils.isIdAssignment)(t, expression) || !(0, _utils.isMethodCall)(t, expression.right, 'filter') || expression.right.arguments.length !== 1) {
				return;
			}

			var filterPath = path.get('expression.right');
			var assignee = expression.left;

			// If the array is the assignee, we need a temp var to hold the array.
			var array = expression.right.callee.object;
			if (t.isIdentifier(array) && array.name === assignee.name) {
				filterPath.get('callee.object').replaceWith((0, _utils.defineId)(t, path, array, 'const', 'arr'));
			}

			var initAssignment = t.assignmentExpression('=', assignee, t.arrayExpression());
			path.insertBefore(t.expressionStatement(initAssignment));

			path.replaceWith(forLoop(t, path, assignee, filterPath));
		},

		VariableDeclaration(path, state) {
			if (path.node.declarations.length !== 1) return;

			var declaration = path.node.declarations[0];
			if (!(0, _utils.isMethodCall)(t, declaration.init, 'filter') || declaration.init.arguments.length !== 1) {
				return;
			}

			var assignee = declaration.id;

			var filterPath = path.get('declarations.0.init');
			path.insertAfter(forLoop(t, path, assignee, filterPath));
			filterPath.replaceWith(t.arrayExpression());
		}
	};
};

function forLoop(t, path, assignee, filterPath) {
	var array = (0, _utils.defineIdIfNeeded)(t, filterPath.get('callee.object'), path);
	var func = (0, _utils.extractDynamicFuncIfNeeded)(t, filterPath, path);
	var i = path.scope.generateUidIdentifier('i');
	var element = t.memberExpression(array, i, true);

	var newFilterCall = t.callExpression(func, [element, i, array]);
	var forBody = t.blockStatement([t.ifStatement(newFilterCall, t.expressionStatement(t.callExpression(t.memberExpression(assignee, t.identifier('push')), [element])))]);

	return (0, _utils.basicArrayForLoop)(t, i, array, forBody);
}