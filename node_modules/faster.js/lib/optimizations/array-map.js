'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _utils = require('../utils');

/**
 * Returns a visitor that rewrites array.map() calls as a for loop.
 *
 * Only supports assignments and single declarations:
 *     results = arr.map(f); // assignment
 *     const results = arr.map(f); // single declaration
 *
 * Only supports 1 argument:
 *     arr.map(f); // call with 1 argument will get compiled
 *     arr.map(f, this); // call with 2 arguments won't get compiled
 */
exports.default = function (t) {
	return {
		ExpressionStatement(path, state) {
			var expression = path.node.expression;
			if (!(0, _utils.isIdAssignment)(t, expression) || !(0, _utils.isMethodCall)(t, expression.right, 'map') || expression.right.arguments.length !== 1) {
				return;
			}

			var mapPath = path.get('expression.right');
			var assignee = expression.left;

			// If the array is the assignee, we need a temp var to hold the array.
			var array = expression.right.callee.object;
			if (t.isIdentifier(array) && array.name === assignee.name) {
				array = (0, _utils.defineId)(t, path, array, 'const', 'arr');
				mapPath.get('callee.object').replaceWith(array);
			} else {
				array = getArray(t, path, mapPath);
			}

			var initAssignment = t.assignmentExpression('=', assignee, arrayAllocExpression(t, array));
			path.insertBefore(t.expressionStatement(initAssignment));

			path.replaceWith(forLoop(t, path, array, assignee, mapPath));
		},

		VariableDeclaration(path, state) {
			if (path.node.declarations.length !== 1) return;

			var declaration = path.node.declarations[0];
			if (!(0, _utils.isMethodCall)(t, declaration.init, 'map') || declaration.init.arguments.length !== 1) {
				return;
			}

			var mapPath = path.get('declarations.0.init');

			var assignee = declaration.id;
			var array = getArray(t, path, mapPath);

			path.insertAfter(forLoop(t, path, array, assignee, mapPath));
			mapPath.replaceWith(arrayAllocExpression(t, array));
		}
	};
};

/**
 * Returns an expression representing:
 *     new Array(array.length)
 */


function arrayAllocExpression(t, array) {
	return t.newExpression(t.identifier('Array'), [t.memberExpression(array, t.identifier('length'))]);
}

function getArray(t, path, mapPath) {
	return (0, _utils.defineIdIfNeeded)(t, mapPath.get('callee.object'), path);
}

function forLoop(t, path, array, assignee, mapPath) {
	var func = (0, _utils.extractDynamicFuncIfNeeded)(t, mapPath, path);
	var i = path.scope.generateUidIdentifier('i');

	var newMapCall = t.callExpression(func, [t.memberExpression(array, i, true), i, array]);
	var forBody = t.blockStatement([t.expressionStatement(t.assignmentExpression('=', t.memberExpression(assignee, i, true), newMapCall))]);

	return (0, _utils.basicArrayForLoop)(t, i, array, forBody);
}